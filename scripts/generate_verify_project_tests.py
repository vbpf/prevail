#!/usr/bin/env python3
# Copyright (c) Prevail Verifier contributors.
# SPDX-License-Identifier: MIT

import argparse
import json
import re
import sys
from pathlib import Path


def cpp_string(value: str) -> str:
    return value.replace("\\", "\\\\").replace('"', '\\"')


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate src/test/test_verify_<project>.cpp from test-data/elf_inventory.json."
    )
    parser.add_argument("--inventory", default="test-data/elf_inventory.json", help="Inventory JSON path.")
    parser.add_argument("--project", help="Project name under projects in inventory JSON.")
    parser.add_argument("--output", help="Output C++ file path.")
    parser.add_argument("--all", action="store_true", help="Generate files for all projects.")
    parser.add_argument("--output-dir", default="src/test", help="Output directory when --all is used.")
    return parser.parse_args()


def section_override(obj: dict, section: str) -> dict | None:
    return obj.get("test_overrides", {}).get("sections", {}).get(section)


def classify_section(obj: dict, section: str, programs: list[dict]) -> tuple[str, str | None]:
    override = section_override(obj, section)
    if override is not None:
        status = override.get("status")
        reason = override.get("reason")
        if status not in ("pass", "expected_failure", "skip"):
            raise ValueError(f"Unsupported status '{status}' for section '{section}'")
        if status in ("expected_failure", "skip") and not reason:
            raise ValueError(f"Missing reason for section '{section}' with status '{status}'")
        return status, reason

    if len(programs) != 1:
        return "skip", f"multi-program section ({len(programs)} programs)"

    if any(program.get("invalid", False) for program in programs):
        reason = next((program.get("invalid_reason") for program in programs if program.get("invalid_reason")), None)
        return "skip", reason or "invalid section in ELF metadata"

    return "pass", None


def render_test(project: str, object_name: str, section_name: str, status: str, reason: str | None) -> list[str]:
    p = cpp_string(project)
    o = cpp_string(object_name)
    s = cpp_string(section_name)
    reason_text = cpp_string(reason or "")

    if status == "pass":
        return [f'TEST_SECTION("{p}", "{o}", "{s}")']
    if status == "expected_failure":
        return [f"// expected failure: {reason}", f'TEST_SECTION_FAIL("{p}", "{o}", "{s}")']
    if status == "skip":
        return [
            f'TEST_CASE("{p}/{o} {s}", "[verify][samples][{p}]") {{',
            f'    SKIP("{reason_text}");',
            "}",
        ]
    raise ValueError(f"Unsupported status '{status}'")


def generate(inventory: dict, project: str) -> str:
    project_entry = inventory.get("projects", {}).get(project)
    if project_entry is None:
        raise ValueError(f"Project '{project}' not found in inventory")

    lines: list[str] = [
        "// Copyright (c) Prevail Verifier contributors.",
        "// SPDX-License-Identifier: MIT",
        "",
        "#include \"test_verify.hpp\"",
        "",
        f"// Generated by scripts/generate_verify_project_tests.py for project '{project}'.",
    ]

    for object_name in sorted(project_entry["objects"].keys()):
        obj = project_entry["objects"][object_name]
        for section_name in sorted(obj["sections"].keys()):
            programs = obj["sections"][section_name]
            status, reason = classify_section(obj, section_name, programs)
            lines.extend(render_test(project, object_name, section_name, status, reason))

    lines.append("")
    return "\n".join(lines)


def project_to_filename(project: str) -> str:
    normalized = re.sub(r"[^a-zA-Z0-9]+", "_", project).strip("_")
    return f"test_verify_{normalized}.cpp"


def main() -> int:
    args = parse_args()
    inventory_path = Path(args.inventory)

    if not inventory_path.exists():
        print(f"error: inventory not found: {inventory_path}", file=sys.stderr)
        return 2

    inventory = json.loads(inventory_path.read_text(encoding="utf-8"))

    if args.all:
        if args.project or args.output:
            print("error: --all cannot be combined with --project/--output", file=sys.stderr)
            return 2
        output_dir = Path(args.output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        for project in sorted(inventory.get("projects", {}).keys()):
            rendered = generate(inventory, project)
            output_path = output_dir / project_to_filename(project)
            output_path.write_text(rendered + "\n", encoding="utf-8")
            print(f"Wrote {output_path}", file=sys.stderr)
        return 0

    if not args.project or not args.output:
        print("error: --project and --output are required unless --all is used", file=sys.stderr)
        return 2

    output_path = Path(args.output)
    rendered = generate(inventory, args.project)
    output_path.write_text(rendered + "\n", encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
