// Copyright (c) Prevail Verifier contributors.
// SPDX-License-Identifier: MIT

#include "test_verify.hpp"

// Generated by scripts/generate_verify_project_tests.py for project 'libbpf-bootstrap'.
TEST_SECTION("libbpf-bootstrap", "bootstrap_legacy.bpf.o", "tp/sched/sched_process_exit")
TEST_SECTION("libbpf-bootstrap", "kprobe.bpf.o", "kprobe/do_unlinkat")
TEST_SECTION("libbpf-bootstrap", "kprobe.bpf.o", "kretprobe/do_unlinkat")
TEST_SECTION("libbpf-bootstrap", "minimal.bpf.o", "tp/syscalls/sys_enter_write")
TEST_SECTION("libbpf-bootstrap", "minimal_legacy.bpf.o", "tp/syscalls/sys_enter_write")
TEST_SECTION("libbpf-bootstrap", "minimal_ns.bpf.o", "tp/syscalls/sys_enter_write")
TEST_SECTION("libbpf-bootstrap", "tc.bpf.o", "tc")
TEST_SECTION("libbpf-bootstrap", "uprobe.bpf.o", "uprobe")
TEST_SECTION("libbpf-bootstrap", "uprobe.bpf.o", "uprobe//proc/self/exe:uprobed_sub")
TEST_SECTION("libbpf-bootstrap", "uprobe.bpf.o", "uretprobe")
TEST_SECTION("libbpf-bootstrap", "uprobe.bpf.o", "uretprobe//proc/self/exe:uprobed_sub")

// ===========================================================================
// Failure Cause Group: VerifierTypeTracking
// Group size: 3 tests (3 expected_failure, 0 skip).
// Root cause:
//   State refinement loses precise register type information across specific control-flow merges, so a pointer or
//   scalar register is later treated as an incompatible type.
// Representative example:
//   test: libbpf-bootstrap/bootstrap_legacy.bpf.o tp/sched/sched_process_exec
//   diagnostic: 70: Invalid type (r3.type == number)
// Addressing direction:
//   Improve type-domain join or widen logic for pointer classes and preserve key path constraints through merges.
//   Start from the first failing instruction and inspect predecessor states.
// ===========================================================================
// expected failure (VerifierTypeTracking):
//   reason: Known verifier limitation: register type refinement is too imprecise in this control-flow pattern.
//   diagnostic: 70: Invalid type (r3.type == number)
TEST_SECTION_FAIL("libbpf-bootstrap", "bootstrap_legacy.bpf.o", "tp/sched/sched_process_exec", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 70: Invalid type (r3.type == number)")
// expected failure (VerifierTypeTracking):
//   reason: Known verifier limitation: register type refinement is too imprecise in this control-flow pattern.
//   diagnostic: 4/33: Invalid type (r1.type in {ctx, stack, packet, shared})
TEST_SECTION_FAIL("libbpf-bootstrap", "usdt.bpf.o", "usdt", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 4/33: Invalid type (r1.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   reason: Known verifier limitation: register type refinement is too imprecise in this control-flow pattern.
//   diagnostic: 4/40: Invalid type (r1.type in {ctx, stack, packet, shared})
TEST_SECTION_FAIL("libbpf-bootstrap", "usdt.bpf.o", "usdt/libc.so.6:libc:setjmp", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 4/40: Invalid type (r1.type in {ctx, stack, packet, shared})")

// ===========================================================================
// Failure Cause Group: VerifierBoundsTracking
// Group size: 8 tests (8 expected_failure, 0 skip).
// Root cause:
//   Numeric range reasoning is too coarse for dependent bounds, so safe accesses fail range checks (packet size,
//   stack window, map value window).
// Representative example:
//   test: libbpf-bootstrap/bootstrap.bpf.o tp/sched/sched_process_exec
//   diagnostic: 24: Lower bound must be at least 0 (valid_access(r7.offset) for comparison/subtraction)
// Addressing direction:
//   Strengthen interval propagation for correlated predicates and arithmetic-derived offsets, and keep relation
//   information across branches where possible.
// ===========================================================================
// expected failure (VerifierBoundsTracking):
//   reason: Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof.
//   diagnostic: 24: Lower bound must be at least 0 (valid_access(r7.offset) for comparison/subtraction)
TEST_SECTION_FAIL("libbpf-bootstrap", "bootstrap.bpf.o", "tp/sched/sched_process_exec", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 24: Lower bound must be at least 0 (valid_access(r7.offset) for comparison/subtraction)")
// expected failure (VerifierBoundsTracking):
//   reason: Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof.
//   diagnostic: 39: Lower bound must be at least 0 (valid_access(r6.offset) for comparison/subtraction)
TEST_SECTION_FAIL("libbpf-bootstrap", "bootstrap.bpf.o", "tp/sched/sched_process_exit", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 39: Lower bound must be at least 0 (valid_access(r6.offset) for comparison/subtraction)")
// expected failure (VerifierBoundsTracking):
//   reason: Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof.
//   diagnostic: 0: Upper bound must be at most 0 (valid_access(r1.offset+8, width=8) for read)
TEST_SECTION_FAIL("libbpf-bootstrap", "fentry.bpf.o", "fentry/do_unlinkat", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 0: Upper bound must be at most 0 (valid_access(r1.offset+8, width=8) for read)")
// expected failure (VerifierBoundsTracking):
//   reason: Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof.
//   diagnostic: 0: Upper bound must be at most 0 (valid_access(r1.offset+16, width=8) for read)
TEST_SECTION_FAIL("libbpf-bootstrap", "fentry.bpf.o", "fexit/do_unlinkat", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 0: Upper bound must be at most 0 (valid_access(r1.offset+16, width=8) for read)")
// expected failure (VerifierBoundsTracking):
//   reason: Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof.
//   diagnostic: 0: Upper bound must be at most 0 (valid_access(r1.offset+24, width=8) for read)
TEST_SECTION_FAIL("libbpf-bootstrap", "lsm.bpf.o", "lsm/bpf", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 0: Upper bound must be at most 0 (valid_access(r1.offset+24, width=8) for read)")
// expected failure (VerifierBoundsTracking):
//   reason: Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof.
//   diagnostic: 12: Lower bound must be at least 0 (valid_access(r7.offset) for comparison/subtraction)
TEST_SECTION_FAIL("libbpf-bootstrap", "profile.bpf.o", "perf_event", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 12: Lower bound must be at least 0 (valid_access(r7.offset) for comparison/subtraction)")
// expected failure (VerifierBoundsTracking):
//   reason: Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof.
//   diagnostic: 27: Lower bound must be at least 0 (valid_access(r7.offset) for comparison/subtraction)
TEST_SECTION_FAIL("libbpf-bootstrap", "sockfilter.bpf.o", "socket", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 27: Lower bound must be at least 0 (valid_access(r7.offset) for comparison/subtraction)")
// expected failure (VerifierBoundsTracking):
//   reason: Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof.
//   diagnostic: 0: Upper bound must be at most 0 (valid_access(r1.offset, width=8) for read)
TEST_SECTION_FAIL("libbpf-bootstrap", "task_iter.bpf.o", "iter/task", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 0: Upper bound must be at most 0 (valid_access(r1.offset, width=8) for read)")

// ===========================================================================
// Failure Cause Group: ExternalSymbolResolution
// Group size: 5 tests (0 expected_failure, 5 skip).
// Root cause:
//   Program references external symbols with no offline resolver or model, so linking cannot complete.
// Representative example:
//   test: libbpf-bootstrap/ksyscall.bpf.o ksyscall/kill
//   diagnostic: Unresolved symbols found.
// Addressing direction:
//   Add explicit platform-level symbol resolution and modeling for required externs, or provide conservative stubs
//   with sound semantics.
// ===========================================================================
// skipped (ExternalSymbolResolution):
//   reason: Known architectural limitation: unresolved external symbols are not modeled in offline verification.
//   diagnostic: Unresolved symbols found.
TEST_SECTION_SKIP("libbpf-bootstrap", "ksyscall.bpf.o", "ksyscall/kill", verify_test::VerifyIssueKind::ExternalSymbolResolution, "Known architectural limitation: unresolved external symbols are not modeled in offline verification. Diagnostic: Unresolved symbols found.")
// skipped (ExternalSymbolResolution):
//   reason: Known architectural limitation: unresolved external symbols are not modeled in offline verification.
//   diagnostic: Unresolved symbols found.
TEST_SECTION_SKIP("libbpf-bootstrap", "ksyscall.bpf.o", "ksyscall/tgkill", verify_test::VerifyIssueKind::ExternalSymbolResolution, "Known architectural limitation: unresolved external symbols are not modeled in offline verification. Diagnostic: Unresolved symbols found.")
// skipped (ExternalSymbolResolution):
//   reason: Known architectural limitation: unresolved external symbols are not modeled in offline verification.
//   diagnostic: Unresolved symbols found.
TEST_PROGRAM_SKIP("libbpf-bootstrap", "usdt.bpf.o", ".text", "bpf_usdt_arg", verify_test::VerifyIssueKind::ExternalSymbolResolution, "Known architectural limitation: unresolved external symbols are not modeled in offline verification. Diagnostic: Unresolved symbols found.")
// skipped (ExternalSymbolResolution):
//   reason: Known architectural limitation: unresolved external symbols are not modeled in offline verification.
//   diagnostic: Unresolved symbols found.
TEST_PROGRAM_SKIP("libbpf-bootstrap", "usdt.bpf.o", ".text", "bpf_usdt_arg_cnt", verify_test::VerifyIssueKind::ExternalSymbolResolution, "Known architectural limitation: unresolved external symbols are not modeled in offline verification. Diagnostic: Unresolved symbols found.")
// skipped (ExternalSymbolResolution):
//   reason: Known architectural limitation: unresolved external symbols are not modeled in offline verification.
//   diagnostic: Unresolved symbols found.
TEST_PROGRAM_SKIP("libbpf-bootstrap", "usdt.bpf.o", ".text", "bpf_usdt_cookie", verify_test::VerifyIssueKind::ExternalSymbolResolution, "Known architectural limitation: unresolved external symbols are not modeled in offline verification. Diagnostic: Unresolved symbols found.")
