// Copyright (c) Prevail Verifier contributors.
// SPDX-License-Identifier: MIT

#include "test_verify.hpp"

// Generated by scripts/generate_verify_project_tests.py for project 'cilium-core'.
TEST_PROGRAM("cilium-core", "bpf_alignchecker.o", "tc/tail", "tail_icmp6_handle_ns", 2)
TEST_PROGRAM("cilium-core", "bpf_alignchecker.o", "tc/tail", "tail_icmp6_send_time_exceeded", 2)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_drop_notify", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_ipv4_from_host", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_ipv4_from_netdev", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_nat_fwd_ipv4", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_nat_fwd_ipv6", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_icmp6_handle_ns", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_icmp6_send_time_exceeded", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_ipv4_dsr", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_ipv6_dsr", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_nat_egress_ipv6", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_rev_dnat_egress_ipv6", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_rev_dnat_ingress_ipv6", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_rev_dnat_ipv4", 28)
TEST_PROGRAM("cilium-core", "bpf_host.o", "tc/tail", "tail_srv6_decap", 28)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/entry", "cil_from_container", 4)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/entry", "cil_lxc_policy", 4)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/entry", "cil_lxc_policy_egress", 4)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/entry", "cil_to_container", 4)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_drop_notify", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_handle_arp", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_handle_ipv4", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_icmp6_handle_ns", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_icmp6_send_time_exceeded", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv4_ct_egress", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv4_ct_ingress", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv4_ct_ingress_policy_only", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv6_ct_egress", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv6_ct_ingress", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv6_ct_ingress_policy_only", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_ipv4_dsr", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_ipv6_dsr", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_nat_egress_ipv6", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_rev_dnat_egress_ipv6", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_rev_dnat_ingress_ipv6", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_rev_dnat_ipv4", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_policy_denied_ipv4", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_srv6_decap", 30)
TEST_PROGRAM("cilium-core", "bpf_lxc.o", "tc/tail", "tail_srv6_encap", 30)
TEST_SECTION("cilium-core", "bpf_network.o", "tc/entry")
TEST_SECTION("cilium-core", "bpf_network.o", "tc/tail")
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/entry", "cil_from_overlay", 2)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_drop_notify", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_handle_arp", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_handle_nat_fwd_ipv4", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_handle_nat_fwd_ipv6", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_icmp6_send_time_exceeded", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_ipv4_dsr", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_ipv6_dsr", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_nat_egress_ipv6", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_rev_dnat_egress_ipv6", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_rev_dnat_ingress_ipv6", 19)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_rev_dnat_ipv4", 19)
TEST_SECTION("cilium-core", "bpf_sock.o", "cgroup/connect4")
TEST_SECTION("cilium-core", "bpf_sock.o", "cgroup/connect6")
TEST_SECTION("cilium-core", "bpf_sock.o", "cgroup/post_bind4")
TEST_SECTION("cilium-core", "bpf_sock.o", "cgroup/post_bind6")
TEST_SECTION("cilium-core", "bpf_sock.o", "cgroup/recvmsg4")
TEST_SECTION("cilium-core", "bpf_sock.o", "cgroup/sendmsg4")
TEST_SECTION("cilium-core", "bpf_sock.o", "cgroup/sendmsg6")
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/entry", "cil_from_wireguard", 2)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/entry", "cil_to_wireguard", 2)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_drop_notify", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_handle_nat_fwd_ipv4", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_handle_nat_fwd_ipv6", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_handle_snat_fwd_ipv4", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_handle_snat_fwd_ipv6", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_icmp6_send_time_exceeded", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_ipv4_dsr", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_ipv6_dsr", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_nat_egress_ipv6", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_rev_dnat_egress_ipv6", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_rev_dnat_ingress_ipv6", 17)
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_rev_dnat_ipv4", 17)
TEST_PROGRAM("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_drop_notify", 12)

// ===========================================================================
// Failure Cause Group: VerifierTypeTracking
// Root cause:
//   State refinement loses precise register type information across specific control-flow merges, so a pointer or
//   scalar register is later treated as an incompatible type.
// Representative example:
//   test: cilium-core/bpf_host.o .text::__check_device_mtu
//   diagnostic: 3: Invalid type (r0.type == number)
// Addressing direction:
//   Improve type-domain join or widen logic for pointer classes and preserve key path constraints through merges.
//   Start from the first failing instruction and inspect predecessor states.
// ===========================================================================
// expected failure (VerifierTypeTracking):
//   diagnostic: 3: Invalid type (r0.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", ".text", "__check_device_mtu", 2,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 3: Invalid type (r0.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 3: Invalid type (r0.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", ".text", "__check_eth_header_length", 2,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 3: Invalid type (r0.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 328: Invalid type (r4.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_ipv4_cont_from_host", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 328: Invalid type (r4.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 299: Invalid type (r3.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_ipv4_cont_from_netdev", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 299: Invalid type (r3.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 203: Invalid type (r3.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_ipv6_cont_from_host", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 203: Invalid type (r3.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 134: Invalid type (r7.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_ipv6_cont_from_netdev", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 134: Invalid type (r7.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 46: Invalid type (r2.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_ipv6_from_host", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 46: Invalid type (r2.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 42: Invalid type (r2.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_ipv6_from_netdev", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 42: Invalid type (r2.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 669: Invalid type (r2.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_handle_snat_fwd_ipv4", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 669: Invalid type (r2.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 840: Invalid type (r3.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_ipv4_host_policy_ingress", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 840: Invalid type (r3.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 296: Invalid type (r9.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_ipv6_host_policy_ingress", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 296: Invalid type (r9.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 689: Invalid type (r3.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_nat_ingress_ipv4", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 689: Invalid type (r3.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 1239: Invalid type (r8.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_nat_ingress_ipv6", 28,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 1239: Invalid type (r8.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 3: Invalid type (r0.type == number)
TEST_SECTION_FAIL("cilium-core", "bpf_lxc.o", ".text", verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 3: Invalid type (r0.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 495: Invalid type (r3.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_handle_ipv4_cont", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 495: Invalid type (r3.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 29: Invalid type (r2.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_handle_ipv6", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 29: Invalid type (r2.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 444: Invalid type (valid_access(r3.offset) for comparison/subtraction)
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_handle_ipv6_cont", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 444: Invalid type (valid_access(r3.offset) for comparison/subtraction)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 464: Invalid type (r3.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv4_policy", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 464: Invalid type (r3.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 521: Invalid type (r1.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv4_to_endpoint", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 521: Invalid type (r1.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 51: Invalid type (r2.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv6_policy", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 51: Invalid type (r2.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 625: Invalid type (r3.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_ipv6_to_endpoint", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 625: Invalid type (r3.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 670: Invalid type (r4.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_nat_ingress_ipv4", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 670: Invalid type (r4.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 1175: Invalid type (r7.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_nat_ingress_ipv6", 30,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 1175: Invalid type (r7.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 3: Invalid type (r0.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", ".text", "__check_device_mtu", 2,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 3: Invalid type (r0.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 9: Invalid type (valid_access(r3.offset) for comparison/subtraction)
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", ".text", "__mcast_ep_delivery", 2,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 9: Invalid type (valid_access(r3.offset) for comparison/subtraction)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 32: Invalid type (r4.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", "tc/tail", "tail_handle_ipv6", 19,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 32: Invalid type (r4.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 1618: Invalid type (r0.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", "tc/tail", "tail_handle_snat_fwd_ipv4", 19,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 1618: Invalid type (r0.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 2349: Invalid type (r5.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", "tc/tail", "tail_handle_snat_fwd_ipv6", 19,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 2349: Invalid type (r5.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 40: Invalid type (r2.type == func)
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", "tc/tail", "tail_mcast_ep_delivery", 19,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 40: Invalid type (r2.type == func)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 668: Invalid type (r4.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_nat_ingress_ipv4", 19,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 668: Invalid type (r4.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 1172: Invalid type (r7.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_nat_ingress_ipv6", 19,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 1172: Invalid type (r7.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 3: Invalid type (r0.type == number)
TEST_SECTION_FAIL("cilium-core", "bpf_wireguard.o", ".text", verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 3: Invalid type (r0.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 32: Invalid type (r5.type == number)
TEST_PROGRAM_FAIL("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_handle_ipv6", 17,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 32: Invalid type (r5.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 668: Invalid type (r9.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_nat_ingress_ipv4", 17,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 668: Invalid type (r9.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 1143: Invalid type (r9.type in {ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_nat_ingress_ipv6", 17,
                  verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 1143: Invalid type (r9.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 3: Invalid type (r0.type == number)
TEST_SECTION_FAIL("cilium-core", "bpf_xdp.o", ".text", verify_test::VerifyIssueKind::VerifierTypeTracking,
                  "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. "
                  "Diagnostic: 3: Invalid type (r0.type == number)")

// ===========================================================================
// Failure Cause Group: VerifierBoundsTracking
// Root cause:
//   Numeric range reasoning is too coarse for dependent bounds, so safe accesses fail range checks (packet size,
//   stack window, map value window).
// Representative example:
//   test: cilium-core/bpf_host.o tc/entry::cil_from_host
//   diagnostic: 27: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)
// Addressing direction:
//   Strengthen interval propagation for correlated predicates and arithmetic-derived offsets, and keep relation
//   information across branches where possible.
// ===========================================================================
// expected failure (VerifierBoundsTracking):
//   diagnostic: 27: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_host.o", "tc/entry", "cil_from_host", 5, verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "27: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 27: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_host.o", "tc/entry", "cil_from_netdev", 5, verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "27: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 18: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_host.o", "tc/entry", "cil_host_policy", 5, verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "18: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 21: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_host.o", "tc/entry", "cil_to_host", 5, verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "21: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 29: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_host.o", "tc/entry", "cil_to_netdev", 5, verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "29: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 70: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_host.o", "tc/tail", "tail_srv6_encap", 28, verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "70: Upper bound must be at most packet_size (valid_access(r1.offset+12, width=1) for read)")
// Previously failed because __sk_buff context was undersized (144 vs actual 192 bytes).
// Now passes with corrected sk_skb_regions = 192.
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/entry", "cil_to_overlay", 2)
TEST_PROGRAM("cilium-core", "bpf_overlay.o", "tc/tail", "tail_handle_ipv4", 19)
// Previously failed because bpf_sock context was undersized (48 vs actual 80 bytes).
// Now passes with corrected cgroup_sock_regions = 80.
TEST_SECTION("cilium-core", "bpf_sock.o", "cgroup/sock_release")
// Previously failed because __sk_buff context was undersized (144 vs actual 192 bytes).
// Now passes with corrected sk_skb_regions = 192.
TEST_PROGRAM("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_handle_ipv4", 17)
// expected failure (VerifierBoundsTracking):
//   diagnostic: 51: Upper bound must be at most packet_size (valid_access(r5.offset, width=1) for read)
TEST_SECTION_FAIL("cilium-core", "bpf_xdp.o", "xdp/entry", verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 51: Upper bound must be at most packet_size (valid_access(r5.offset, width=1) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 170: Upper bound must be at most packet_size (valid_access(r4.offset, width=4) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_xdp.o", "xdp/tail", "tail_lb_ipv4", 12, verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "170: Upper bound must be at most packet_size (valid_access(r4.offset, width=4) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 66: Upper bound must be at most packet_size (valid_access(r3.offset, width=2) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_lb_ipv6", 12,
                  verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 66: Upper bound must be at most packet_size (valid_access(r3.offset, width=2) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 283: Upper bound must be at most packet_size (valid_access(r0.offset, width=2) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_ipv4_dsr", 12,
    verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "283: Upper bound must be at most packet_size (valid_access(r0.offset, width=2) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 76: Upper bound must be at most packet_size (valid_access(r3.offset, width=2) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_ipv6_dsr", 12,
                  verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 76: Upper bound must be at most packet_size (valid_access(r3.offset, width=2) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 97: Upper bound must be at most packet_size (valid_access(r4.offset, width=4) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_nat_egress_ipv4", 12,
                  verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 97: Upper bound must be at most packet_size (valid_access(r4.offset, width=4) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 74: Upper bound must be at most packet_size (valid_access(r4.offset, width=2) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_nat_egress_ipv6", 12,
                  verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 74: Upper bound must be at most packet_size (valid_access(r4.offset, width=2) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 82: Upper bound must be at most packet_size (valid_access(r4.offset, width=4) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_nat_ingress_ipv4", 12,
                  verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 82: Upper bound must be at most packet_size (valid_access(r4.offset, width=4) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 47: Upper bound must be at most packet_size (valid_access(r4.offset, width=2) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_nat_ingress_ipv6", 12,
                  verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 47: Upper bound must be at most packet_size (valid_access(r4.offset, width=2) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 60: Upper bound must be at most packet_size (valid_access(r4.offset, width=2) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_rev_dnat_egress_ipv6", 12,
                  verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 60: Upper bound must be at most packet_size (valid_access(r4.offset, width=2) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 60: Upper bound must be at most packet_size (valid_access(r4.offset, width=2) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_rev_dnat_ingress_ipv6", 12,
                  verify_test::VerifyIssueKind::VerifierBoundsTracking,
                  "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. "
                  "Diagnostic: 60: Upper bound must be at most packet_size (valid_access(r4.offset, width=2) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 139: Upper bound must be at most packet_size (valid_access(r4.offset, width=4) for read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_xdp.o", "xdp/tail", "tail_nodeport_rev_dnat_ipv4", 12,
    verify_test::VerifyIssueKind::VerifierBoundsTracking,
    "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: "
    "139: Upper bound must be at most packet_size (valid_access(r4.offset, width=4) for read)")

// ===========================================================================
// Failure Cause Group: VerifierStackInitialization
// Root cause:
//   Stack byte initialization tracking misses writes or invalidates facts too aggressively, so reads are reported as
//   non-numeric or uninitialized.
// Representative example:
//   test: cilium-core/bpf_host.o tc/tail::tail_nodeport_nat_egress_ipv4
//   diagnostic: 1026: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)
// Addressing direction:
//   Tighten per-byte initialization transfer functions and join behavior for stack slots touched through aliases and
//   conditional writes.
// ===========================================================================
// expected failure (VerifierStackInitialization):
//   diagnostic: 1026: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_host.o", "tc/tail", "tail_nodeport_nat_egress_ipv4", 28,
                  verify_test::VerifyIssueKind::VerifierStackInitialization,
                  "Known verifier limitation: stack initialization tracking is too coarse for this access path. "
                  "Diagnostic: 1026: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)")
// expected failure (VerifierStackInitialization):
//   diagnostic: 1011: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_lxc.o", "tc/tail", "tail_nodeport_nat_egress_ipv4", 30,
                  verify_test::VerifyIssueKind::VerifierStackInitialization,
                  "Known verifier limitation: stack initialization tracking is too coarse for this access path. "
                  "Diagnostic: 1011: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)")
// expected failure (VerifierStackInitialization):
//   diagnostic: 1010: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_overlay.o", "tc/tail", "tail_nodeport_nat_egress_ipv4", 19,
                  verify_test::VerifyIssueKind::VerifierStackInitialization,
                  "Known verifier limitation: stack initialization tracking is too coarse for this access path. "
                  "Diagnostic: 1010: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)")
// expected failure (VerifierStackInitialization):
//   diagnostic: 1009: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)
TEST_PROGRAM_FAIL("cilium-core", "bpf_wireguard.o", "tc/tail", "tail_nodeport_nat_egress_ipv4", 17,
                  verify_test::VerifyIssueKind::VerifierStackInitialization,
                  "Known verifier limitation: stack initialization tracking is too coarse for this access path. "
                  "Diagnostic: 1009: Stack content is not numeric (valid_access(r2.offset+32, width=4) for read)")

// ===========================================================================
// Failure Cause Group: VerifierMapTyping
// Root cause:
//   Map key or value region typing cannot prove scalar compatibility for helper arguments in these flows.
// Representative example:
//   test: cilium-core/bpf_sock.o cgroup/recvmsg6
//   diagnostic: 303: Illegal map update with a non-numerical value [4048-4072) (within(r2:key_size(r1)))
// Addressing direction:
//   Improve map region typing and value or key scalarization so helper argument checks can recover precise numeric
//   facts.
// ===========================================================================
// expected failure (VerifierMapTyping):
//   diagnostic: 303: Illegal map update with a non-numerical value [4048-4072) (within(r2:key_size(r1)))
TEST_SECTION_FAIL(
    "cilium-core", "bpf_sock.o", "cgroup/recvmsg6", verify_test::VerifyIssueKind::VerifierMapTyping,
    "Known verifier limitation: map value/key typing and scalarization are too conservative here. Diagnostic: 303: "
    "Illegal map update with a non-numerical value [4048-4072) (within(r2:key_size(r1)))")

// ===========================================================================
// Failure Cause Group: VerifierNullability
// Root cause:
//   Null-state tracking is conservative across paths, so values proven non-null on one path are reintroduced as
//   maybe-null later.
// Representative example:
//   test: cilium-core/bpf_host.o tc/tail::tail_handle_snat_fwd_ipv6
//   diagnostic: 927: Non-null number ((r2.type == number and r2.value == 0) or valid_access(r2.offset, width=r3) for
//               read)
// Addressing direction:
//   Refine nullability join rules and path-sensitive implication handling for pointer checks before access.
// ===========================================================================
// expected failure (VerifierNullability):
//   diagnostic: 927: Non-null number ((r2.type == number and r2.value == 0) or valid_access(r2.offset, width=r3) for
//               read)
TEST_PROGRAM_FAIL(
    "cilium-core", "bpf_host.o", "tc/tail", "tail_handle_snat_fwd_ipv6", 28,
    verify_test::VerifyIssueKind::VerifierNullability,
    "Known verifier limitation: nullability tracking is too conservative on this path. Diagnostic: 927: Non-null "
    "number ((r2.type == number and r2.value == 0) or valid_access(r2.offset, width=r3) for read)")
