// Copyright (c) Prevail Verifier contributors.
// SPDX-License-Identifier: MIT

#include "test_verify.hpp"

// Generated by scripts/generate_verify_project_tests.py for project 'build'.
TEST_SECTION("build", "badrelo.o", ".text")
TEST_SECTION("build", "bounded_loop.o", "test")
TEST_PROGRAM("build", "bpf2bpf.o", ".text", "add1", 2)
TEST_PROGRAM("build", "bpf2bpf.o", ".text", "add2", 2)
TEST_SECTION("build", "bpf2bpf.o", "test")
TEST_SECTION("build", "byteswap.o", ".text")
TEST_SECTION("build", "cpumap.o", "xdp")
TEST_SECTION("build", "devmap.o", "xdp")
TEST_SECTION("build", "divzero.o", "test")
TEST_SECTION("build", "externalfunction.o", ".text")
TEST_SECTION("build", "global_func.o", "xdp")
TEST_SECTION("build", "global_variable.o", ".text")
TEST_SECTION("build", "global_variable_2.o", ".text")
TEST_SECTION("build", "hash_of_maps.o", ".text")
TEST_SECTION("build", "infinite_loop.o", "test")
TEST_SECTION("build", "lpm_trie.o", "xdp")
TEST_SECTION("build", "map_in_map.o", ".text")
TEST_SECTION("build", "map_in_map_anonymous.o", ".text")
TEST_SECTION("build", "map_in_map_legacy.o", ".text")
TEST_SECTION("build", "map_in_map_typedef.o", ".text")
TEST_SECTION("build", "mapoverflow.o", ".text")
TEST_SECTION("build", "mapunderflow.o", ".text")
TEST_SECTION("build", "packet_access.o", "xdp")
TEST_SECTION("build", "packet_start_ok.o", "xdp")
TEST_SECTION("build", "percpu_array.o", "xdp")
TEST_SECTION("build", "percpu_hash.o", "xdp")
TEST_PROGRAM("build", "prog_array.o", ".text", "func", 5)
TEST_PROGRAM("build", "prog_array.o", ".text", "func0", 5)
TEST_PROGRAM("build", "prog_array.o", ".text", "func1", 5)
TEST_PROGRAM("build", "prog_array.o", ".text", "func2", 5)
TEST_PROGRAM("build", "prog_array.o", ".text", "func3", 5)
TEST_SECTION("build", "sockmap.o", "sk_skb/stream_verdict")
TEST_SECTION("build", "stackok.o", ".text")
TEST_SECTION("build", "store_map_value_in_map.o", ".text")
TEST_SECTION("build", "tail_call.o", "xdp_prog")
TEST_SECTION("build", "tail_call.o", "xdp_prog/0")
TEST_SECTION("build", "tail_call_bad.o", "xdp_prog/0")
TEST_SECTION("build", "twomaps.o", ".text")
TEST_SECTION("build", "twomaps_btf.o", ".text")
TEST_SECTION("build", "twostackvars.o", ".text")
TEST_SECTION("build", "twotypes.o", ".text")

// ===========================================================================
// Failure Cause Group: VerifierTypeTracking
// Group size: 8 tests (8 expected_failure, 0 skip).
// Root cause:
//   State refinement loses precise register type information across specific control-flow merges, so a pointer or
//   scalar register is later treated as an incompatible type.
// Representative example:
//   test: build/badmapptr.o test
//   diagnostic: 4: Invalid type (r1.type in {number, ctx, stack, packet, shared})
// Addressing direction:
//   Improve type-domain join or widen logic for pointer classes and preserve key path constraints through merges.
//   Start from the first failing instruction and inspect predecessor states.
// ===========================================================================
// expected failure (VerifierTypeTracking):
//   diagnostic: 4: Invalid type (r1.type in {number, ctx, stack, packet, shared})
TEST_SECTION_FAIL("build", "badmapptr.o", "test", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 4: Invalid type (r1.type in {number, ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 8: Invalid type (r2.type == func)
TEST_SECTION_FAIL("build", "bpf_loop_helper.o", "xdp", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 8: Invalid type (r2.type == func)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 16: Invalid type (r7.type in {ctx, stack, packet, shared})
TEST_SECTION_FAIL("build", "correlated_branch.o", "xdp", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 16: Invalid type (r7.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 1: Invalid type (r3.type in {number, ctx, stack, packet, shared})
TEST_PROGRAM_FAIL("build", "global_func.o", ".text", "add_and_store", 2, verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 1: Invalid type (r3.type in {number, ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 13: Invalid type (r7.type in {ctx, stack, packet, shared})
TEST_SECTION_FAIL("build", "packet_reallocate.o", "socket_filter", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 13: Invalid type (r7.type in {ctx, stack, packet, shared})")
// expected failure (VerifierTypeTracking):
//   diagnostic: 30: Invalid type (r0.type == number)
TEST_SECTION_FAIL("build", "queue_stack.o", ".text", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 30: Invalid type (r0.type == number)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 19: Invalid type (r1.type == map_fd)
TEST_SECTION_FAIL("build", "ringbuf_in_map.o", ".text", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 19: Invalid type (r1.type == map_fd)")
// expected failure (VerifierTypeTracking):
//   diagnostic: 3: Invalid type (r2.type == map_fd_programs)
TEST_SECTION_FAIL("build", "tail_call_bad.o", "xdp_prog", verify_test::VerifyIssueKind::VerifierTypeTracking, "Known verifier limitation: register type refinement is too imprecise in this control-flow pattern. Diagnostic: 3: Invalid type (r2.type == map_fd_programs)")

// ===========================================================================
// Failure Cause Group: VerifierBoundsTracking
// Group size: 6 tests (6 expected_failure, 0 skip).
// Root cause:
//   Numeric range reasoning is too coarse for dependent bounds, so safe accesses fail range checks (packet size,
//   stack window, map value window).
// Representative example:
//   test: build/badhelpercall.o .text
//   diagnostic: 3: Upper bound must be at most EBPF_TOTAL_STACK_SIZE (valid_access(r1.offset, width=r2) for write)
// Addressing direction:
//   Strengthen interval propagation for correlated predicates and arithmetic-derived offsets, and keep relation
//   information across branches where possible.
// ===========================================================================
// expected failure (VerifierBoundsTracking):
//   diagnostic: 3: Upper bound must be at most EBPF_TOTAL_STACK_SIZE (valid_access(r1.offset, width=r2) for write)
TEST_SECTION_FAIL("build", "badhelpercall.o", ".text", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 3: Upper bound must be at most EBPF_TOTAL_STACK_SIZE (valid_access(r1.offset, width=r2) for write)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 10: Upper bound must be at most packet_size (valid_access(r1.offset, width=4) for read)
TEST_SECTION_FAIL("build", "dependent_read.o", "xdp", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 10: Upper bound must be at most packet_size (valid_access(r1.offset, width=4) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 19: Upper bound must be at most r1.shared_region_size (valid_access(r1.offset, width=4) for write)
TEST_SECTION_FAIL("build", "invalid_map_access.o", ".text", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 19: Upper bound must be at most r1.shared_region_size (valid_access(r1.offset, width=4) for write)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 15: Upper bound must be at most EBPF_TOTAL_STACK_SIZE (valid_access(r5.offset, width=1) for write)
TEST_SECTION_FAIL("build", "loop.o", "test_md", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 15: Upper bound must be at most EBPF_TOTAL_STACK_SIZE (valid_access(r5.offset, width=1) for write)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 10: Upper bound must be at most r1.shared_region_size (valid_access(r1.offset, width=8) for read)
TEST_SECTION_FAIL("build", "mapvalue-overrun.o", ".text", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 10: Upper bound must be at most r1.shared_region_size (valid_access(r1.offset, width=8) for read)")
// expected failure (VerifierBoundsTracking):
//   diagnostic: 4: Upper bound must be at most packet_size (valid_access(r2.offset, width=4) for read)
TEST_SECTION_FAIL("build", "packet_overflow.o", "xdp", verify_test::VerifyIssueKind::VerifierBoundsTracking, "Known verifier limitation: interval/bounds refinement loses precision for this memory-access proof. Diagnostic: 4: Upper bound must be at most packet_size (valid_access(r2.offset, width=4) for read)")

// ===========================================================================
// Failure Cause Group: VerifierStackInitialization
// Group size: 3 tests (3 expected_failure, 0 skip).
// Root cause:
//   Stack byte initialization tracking misses writes or invalidates facts too aggressively, so reads are reported as
//   non-numeric or uninitialized.
// Representative example:
//   test: build/correlated_branch2.o socket_filter
//   diagnostic: 52: Stack content is not numeric (valid_access(r3.offset, width=r4) for read)
// Addressing direction:
//   Tighten per-byte initialization transfer functions and join behavior for stack slots touched through aliases and
//   conditional writes.
// ===========================================================================
// expected failure (VerifierStackInitialization):
//   diagnostic: 52: Stack content is not numeric (valid_access(r3.offset, width=r4) for read)
TEST_SECTION_FAIL("build", "correlated_branch2.o", "socket_filter", verify_test::VerifyIssueKind::VerifierStackInitialization, "Known verifier limitation: stack initialization tracking is too coarse for this access path. Diagnostic: 52: Stack content is not numeric (valid_access(r3.offset, width=r4) for read)")
// expected failure (VerifierStackInitialization):
//   diagnostic: 12: Stack content is not numeric (valid_access(r4.offset, width=r5) for read)
TEST_SECTION_FAIL("build", "perf_event_array.o", "xdp", verify_test::VerifyIssueKind::VerifierStackInitialization, "Known verifier limitation: stack initialization tracking is too coarse for this access path. Diagnostic: 12: Stack content is not numeric (valid_access(r4.offset, width=r5) for read)")
// expected failure (VerifierStackInitialization):
//   diagnostic: 6: Stack content is not numeric (valid_access(r2.offset, width=r3) for read)
TEST_SECTION_FAIL("build", "ringbuf_uninit.o", ".text", verify_test::VerifyIssueKind::VerifierStackInitialization, "Known verifier limitation: stack initialization tracking is too coarse for this access path. Diagnostic: 6: Stack content is not numeric (valid_access(r2.offset, width=r3) for read)")

// ===========================================================================
// Failure Cause Group: VerifierPointerArithmetic
// Group size: 1 tests (1 expected_failure, 0 skip).
// Root cause:
//   Pointer arithmetic rules are stricter than required for this pattern, rejecting arithmetic that should remain
//   safely typed.
// Representative example:
//   test: build/ptr_arith.o xdp
//   diagnostic: 2: Only numbers can be added to pointers (r2.type in {ctx, stack, packet, shared} -> r1.type ==
//               number)
// Addressing direction:
//   Refine pointer-plus-scalar typing rules and preserve provenance when arithmetic stays within verified bounds.
// ===========================================================================
// expected failure (VerifierPointerArithmetic):
//   diagnostic: 2: Only numbers can be added to pointers (r2.type in {ctx, stack, packet, shared} -> r1.type ==
//               number)
TEST_SECTION_FAIL("build", "ptr_arith.o", "xdp", verify_test::VerifyIssueKind::VerifierPointerArithmetic, "Known verifier limitation: pointer-arithmetic typing is too restrictive in this pattern. Diagnostic: 2: Only numbers can be added to pointers (r2.type in {ctx, stack, packet, shared} -> r1.type == number)")

// ===========================================================================
// Failure Cause Group: VerifierMapTyping
// Group size: 4 tests (4 expected_failure, 0 skip).
// Root cause:
//   Map key or value region typing cannot prove scalar compatibility for helper arguments in these flows.
// Representative example:
//   test: build/bpf_loop_helper.o .text
//   diagnostic: 6: Illegal map update with a non-numerical value [4092-4096) (within(r2:key_size(r1)))
// Addressing direction:
//   Improve map region typing and value or key scalarization so helper argument checks can recover precise numeric
//   facts.
// ===========================================================================
// expected failure (VerifierMapTyping):
//   diagnostic: 6: Illegal map update with a non-numerical value [4092-4096) (within(r2:key_size(r1)))
TEST_SECTION_FAIL("build", "bpf_loop_helper.o", ".text", verify_test::VerifyIssueKind::VerifierMapTyping, "Known verifier limitation: map value/key typing and scalarization are too conservative here. Diagnostic: 6: Illegal map update with a non-numerical value [4092-4096) (within(r2:key_size(r1)))")
// expected failure (VerifierMapTyping):
//   diagnostic: 10: Illegal map update with a non-numerical value [4088-4096) (within(r3:value_size(r1)))
TEST_SECTION_FAIL("build", "exposeptr.o", ".text", verify_test::VerifyIssueKind::VerifierMapTyping, "Known verifier limitation: map value/key typing and scalarization are too conservative here. Diagnostic: 10: Illegal map update with a non-numerical value [4088-4096) (within(r3:value_size(r1)))")
// expected failure (VerifierMapTyping):
//   diagnostic: 10: Illegal map update with a non-numerical value [4088-4096) (within(r2:key_size(r1)))
TEST_SECTION_FAIL("build", "exposeptr2.o", ".text", verify_test::VerifyIssueKind::VerifierMapTyping, "Known verifier limitation: map value/key typing and scalarization are too conservative here. Diagnostic: 10: Illegal map update with a non-numerical value [4088-4096) (within(r2:key_size(r1)))")
// expected failure (VerifierMapTyping):
//   diagnostic: 5: Illegal map update with a non-numerical value [4092-4096) (within(r2:key_size(r1)))
TEST_PROGRAM_FAIL("build", "global_func.o", ".text", "process_entry", 2, verify_test::VerifyIssueKind::VerifierMapTyping, "Known verifier limitation: map value/key typing and scalarization are too conservative here. Diagnostic: 5: Illegal map update with a non-numerical value [4092-4096) (within(r2:key_size(r1)))")

// ===========================================================================
// Failure Cause Group: VerifierNullability
// Group size: 1 tests (1 expected_failure, 0 skip).
// Root cause:
//   Null-state tracking is conservative across paths, so values proven non-null on one path are reintroduced as
//   maybe-null later.
// Representative example:
//   test: build/nullmapref.o test
//   diagnostic: 7: Possible null access (valid_access(r0.offset, width=4) for write)
// Addressing direction:
//   Refine nullability join rules and path-sensitive implication handling for pointer checks before access.
// ===========================================================================
// expected failure (VerifierNullability):
//   diagnostic: 7: Possible null access (valid_access(r0.offset, width=4) for write)
TEST_SECTION_FAIL("build", "nullmapref.o", "test", verify_test::VerifyIssueKind::VerifierNullability, "Known verifier limitation: nullability tracking is too conservative on this path. Diagnostic: 7: Possible null access (valid_access(r0.offset, width=4) for write)")

// ===========================================================================
// Failure Cause Group: VerifierContextModeling
// Group size: 1 tests (1 expected_failure, 0 skip).
// Root cause:
//   Platform context model does not expose offset semantics expected by the program, so accesses are rejected.
// Representative example:
//   test: build/ctxoffset.o sockops
//   diagnostic: 8: Nonzero context offset (r1.ctx_offset == 0)
// Addressing direction:
//   Extend context layout and offset modeling for the relevant program type.
// ===========================================================================
// expected failure (VerifierContextModeling):
//   diagnostic: 8: Nonzero context offset (r1.ctx_offset == 0)
TEST_SECTION_FAIL("build", "ctxoffset.o", "sockops", verify_test::VerifyIssueKind::VerifierContextModeling, "Known verifier limitation: context-offset modeling is too restrictive for this access pattern. Diagnostic: 8: Nonzero context offset (r1.ctx_offset == 0)")

// ===========================================================================
// Failure Cause Group: PlatformHelperAvailability
// Group size: 1 tests (0 expected_failure, 1 skip).
// Root cause:
//   Sample expects helper availability that differs from the modeled target platform.
// Representative example:
//   test: build/wronghelper.o xdp
//   diagnostic: error: rejected: helper function is unavailable on this platform (at 7)
// Addressing direction:
//   Update platform helper matrix or test platform assumptions; keep behavior explicit per target profile.
// ===========================================================================
// skipped (PlatformHelperAvailability):
//   diagnostic: error: rejected: helper function is unavailable on this platform (at 7)
TEST_SECTION_SKIP("build", "wronghelper.o", "xdp", verify_test::VerifyIssueKind::PlatformHelperAvailability, "Known platform-model limitation: helper availability differs from the sample expectation. Diagnostic: error: rejected: helper function is unavailable on this platform (at 7)")
